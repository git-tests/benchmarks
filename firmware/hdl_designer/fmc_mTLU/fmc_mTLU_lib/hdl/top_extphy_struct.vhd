-- VHDL Entity fmc_mTLU_lib.top_extphy.symbol
--
-- Created:
--          by - phdgc.HEP_Instrumentation (kipper.phy.bris.ac.uk)
--          at - 12:28:37 11/15/12
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.3 (Build 21)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY top_extphy IS
   GENERIC( 
      NUM_DUTS         : positive := 3;
      NUM_TRIG_INPUTS  : positive := 4;
      NUM_EXT_SLAVES   : positive := 5;      --! Number of slaves outside IPBus interface
      EVENT_DATA_WIDTH : positive := 64;
      IPBUS_WIDTH      : positive := 32
   );
   PORT( 
      busy_i            : IN     std_logic_vector (NUM_DUTS-1 DOWNTO 0);
      cfd_discr_i       : IN     std_logic_vector (NUM_TRIG_INPUTS-1 DOWNTO 0);
      dip_switch        : IN     std_logic_vector (3 DOWNTO 0);
      dut_clk           : IN     std_logic_vector (NUM_DUTS-1 DOWNTO 0);
      gmii_rx_clk_i     : IN     std_logic;
      gmii_rx_dv_i      : IN     std_logic;
      gmii_rx_er_i      : IN     std_logic;
      gmii_rxd_i        : IN     std_logic_vector (7 DOWNTO 0);
      sysclk_n_i        : IN     std_logic;
      sysclk_p_i        : IN     std_logic;                                      -- ! 200 MHz xtal clock
      threshold_discr_i : IN     std_logic_vector (NUM_TRIG_INPUTS-1 DOWNTO 0);
      gmii_gtx_clk_o    : OUT    std_logic;
      gmii_tx_en_o      : OUT    std_logic;
      gmii_tx_er_o      : OUT    std_logic;
      gmii_txd_o        : OUT    std_logic_vector (7 DOWNTO 0);
      i2c_scl_o         : OUT    std_logic;
      leds              : OUT    std_logic_vector (3 DOWNTO 0);
      leds_o            : OUT    std_logic_vector (3 DOWNTO 0);
      phy_rstb_o        : OUT    std_logic;
      reset_or_clk_o    : OUT    std_logic_vector (NUM_DUTS-1 DOWNTO 0);
      triggers_o        : OUT    std_logic_vector (NUM_DUTS-1 DOWNTO 0);
      extclk_n_b        : INOUT  std_logic;
      extclk_p_b        : INOUT  std_logic;                                      -- either external clock in, or a clock being driven out
      i2c_sda_d         : INOUT  std_logic
   );

-- Declarations

END ENTITY top_extphy ;

--
-- VHDL Architecture fmc_mTLU_lib.top_extphy.struct
--
-- Created:
--          by - phdgc.HEP_Instrumentation (kipper.phy.bris.ac.uk)
--          at - 12:28:37 11/15/12
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.3 (Build 21)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

LIBRARY work;
USE work.ipbus.all;
USE work.emac_hostbus_decl.all;

USE work.fmcTLU.all;
LIBRARY unisim;
USE unisim.vcomponents.all;

LIBRARY fmc_mTLU_lib;

ARCHITECTURE struct OF top_extphy IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL buffer_full_o    : std_logic;                                         --! Goes high when event buffer almost full
   SIGNAL clk_16x_logic    : std_logic;                                         -- 640MHz clock
   SIGNAL clk_4x_logic     : std_logic;                                         -- ! normally 160MHz
   SIGNAL clk_logic_xtal   : std_logic;                                         -- ! 40MHz clock from onboard xtal
   SIGNAL data_strobe      : std_logic;                                         -- goes high when data ready to load into event buffer
   SIGNAL event_data       : std_logic_vector(EVENT_DATA_WIDTH-1 DOWNTO 0);
   SIGNAL ipb_clk          : std_logic;                                         -- ! IPBus clock to slaves
   SIGNAL ipb_rst          : std_logic;                                         -- ! IPBus reset to slaves
   SIGNAL ipbr             : ipb_rbus_array(NUM_EXT_SLAVES-1 DOWNTO 0);         -- ! IPBus read signals
   SIGNAL ipbus_clk        : std_logic;
   SIGNAL ipbus_reset      : std_logic;
   SIGNAL ipbw             : ipb_wbus_array(NUM_EXT_SLAVES-1 DOWNTO 0);         -- ! IBus write signals
   SIGNAL overall_trigger  : std_logic;                                         -- goes high to load trigger data
   SIGNAL overall_veto     : std_logic;                                         -- ! Halts triggers when high
   SIGNAL strobe_16x_logic : std_logic;                                         -- strobes once every 4 cycles of clk_16x
   SIGNAL strobe_4x_logic  : std_logic;                                         -- one pulse every 4 cycles of clk_4x
   SIGNAL trigger_count    : std_logic_vector(IPBUS_WIDTH-1 DOWNTO 0);
   SIGNAL trigger_times    : t_triggerTimeArray(NUM_TRIG_INPUTS-1 DOWNTO 0);    -- ! trigger arrival time ( w.r.t. logic_strobe)
   SIGNAL triggers         : std_logic_vector(NUM_TRIG_INPUTS-1 DOWNTO 0);      -- ! High when trigger from input conector active
   SIGNAL veto_o           : std_logic;                                         -- goes high when one or more DUT are busy


   -- Component Declarations
   COMPONENT DUTInterfaces
   GENERIC (
      NUM_DUTS    : positive := 3;
      IPBUS_WIDTH : positive := 32
   );
   PORT (
      busy_from_dut_i       : IN     std_logic_vector (NUM_DUTS-1 DOWNTO 0);  -- BUSY input from DUTs
      clk_4x_logic_i        : IN     std_logic ;
      clk_from_dut_i        : IN     std_logic_vector (NUM_DUTS-1 DOWNTO 0);  -- clocks trigger data when in EUDET mode
      ipbus_clk_i           : IN     std_logic ;
      ipbus_i               : IN     ipb_wbus ;                               -- Signals from IPBus core TO slave
      ipbus_reset_i         : IN     std_logic ;
      logic_strobe_i        : IN     std_logic ;                              -- ! goes high every 4th clock cycle
      trigger_counter_i     : IN     std_logic_vector (IPBUS_WIDTH-1 DOWNTO 0);
      trigger_i             : IN     std_logic ;                              -- goes high when trigger logic issues a trigger
      ipbus_o               : OUT    ipb_rbus ;                               -- signals from slave TO IPBus core
      reset_or_clk_to_dut_o : OUT    std_logic_vector (NUM_DUTS-1 DOWNTO 0);  -- ! Either reset line or trigger
      trigger_to_dut_o      : OUT    std_logic_vector (NUM_DUTS-1 DOWNTO 0);  -- ! Trigger output
      veto_o                : OUT    std_logic                                -- goes high when one or more DUT are busy
   );
   END COMPONENT DUTInterfaces;
   COMPONENT IPBusInterface
   GENERIC (
      NUM_EXT_SLAVES : positive := 5
   );
   PORT (
      gmii_rx_clk_i    : IN     std_logic ;
      gmii_rx_dv_i     : IN     std_logic ;
      gmii_rx_er_i     : IN     std_logic ;
      gmii_rxd_i       : IN     std_logic_vector (7 DOWNTO 0);
      ipbr_i           : IN     ipb_rbus_array (NUM_EXT_SLAVES-1 DOWNTO 0); -- ! IPBus read signals
      sysclk_n_i       : IN     std_logic ;
      sysclk_p_i       : IN     std_logic ;                                 -- ! 200 MHz xtal clock
      clocks_locked_o  : OUT    std_logic ;
      gmii_gtx_clk_o   : OUT    std_logic ;
      gmii_tx_en_o     : OUT    std_logic ;
      gmii_tx_er_o     : OUT    std_logic ;
      gmii_txd_o       : OUT    std_logic_vector (7 DOWNTO 0);
      ipb_clk_o        : OUT    std_logic ;                                 -- ! IPBus clock TO slaves
      ipb_rst_o        : OUT    std_logic ;                                 -- ! IPBus reset TO slaves
      ipbw_o           : OUT    ipb_wbus_array (NUM_EXT_SLAVES-1 DOWNTO 0); -- ! IBus write signals
      onehz_o          : OUT    std_logic ;
      phy_rstb_o       : OUT    std_logic ;
      dip_switch_i     : IN     std_logic_vector (3 DOWNTO 0);
      clk_logic_xtal_o : OUT    std_logic 
   );
   END COMPONENT IPBusInterface;
   COMPONENT eventBuffer
   GENERIC (
      EVENT_DATA_WIDTH : positive := 64;
      IPBUS_WIDTH      : positive := 32
   );
   PORT (
      clk_4x_logic_i    : IN     std_logic ;
      data_strobe_i     : IN     std_logic ;                                   -- Indicates data TO transfer
      event_data_i      : IN     std_logic_vector (EVENT_DATA_WIDTH-1 DOWNTO 0);
      ipbus_clk_i       : IN     std_logic ;
      ipbus_i           : IN     ipb_wbus ;
      ipbus_reset_i     : IN     std_logic ;
      strobe_4x_logic_i : IN     std_logic ;
      trigger_count_i   : IN     std_logic_vector (IPBUS_WIDTH-1 DOWNTO 0);
      buffer_full_o     : OUT    std_logic ;                                   --! Goes high when event buffer almost full
      ipbus_o           : OUT    ipb_rbus 
   );
   END COMPONENT eventBuffer;
   COMPONENT eventFormatter
   GENERIC (
      EVENT_DATA_WIDTH : positive := 64;
      IPBUS_WIDTH      : positive := 32;
      NUM_TRIG_INPUTS  : positive := 4
   );
   PORT (
      clk_4x_logic_i  : IN     std_logic ;                                      -- ! Rising edge active
      logic_strobe_i  : IN     std_logic ;                                      -- ! Pulses high once every 4 cycles of clk_4x_logic
      trigger_i       : IN     std_logic ;                                      -- goes high TO load trigger data
      trigger_times_i : IN     t_triggerTimeArray (NUM_TRIG_INPUTS-1 DOWNTO 0); -- Array of trigger times ( w.r.t. logic_strobe)
      data_strobe_o   : OUT    std_logic ;                                      -- goes high when data ready TO load into event buffer
      event_data_o    : OUT    std_logic_vector (EVENT_DATA_WIDTH-1 DOWNTO 0);
      trigger_count_o : OUT    std_logic_vector (IPBUS_WIDTH-1 DOWNTO 0)
   );
   END COMPONENT eventFormatter;
   COMPONENT logic_clocks
   PORT (
      ipbus_clk_i        : IN     std_logic ;
      ipbus_i            : IN     ipb_wbus ;
      ipbus_reset_i      : IN     std_logic ;
      clk_logic_xtal_i   : IN     std_logic ; -- ! 40MHz clock from onboard xtal
      clk_16x_logic_O    : OUT    std_logic ; -- 640MHz clock
      clk_4x_logic_o     : OUT    std_logic ; -- 160MHz clock
      ipbus_o            : OUT    ipb_rbus ;
      strobe_16x_logic_O : OUT    std_logic ; -- strobes once every 4 cycles of clk_16x
      strobe_4x_logic_O  : OUT    std_logic ; -- one pulse every 4 cycles of clk_4x
      extclk_p_b         : INOUT  std_logic ; -- either external clock in, or a clock being driven out
      extclk_n_b         : INOUT  std_logic ;
      clk_logic_o        : OUT    std_logic 
   );
   END COMPONENT logic_clocks;
   COMPONENT triggerInputs
   GENERIC (
      NUM_INPUTS : natural := 4
   );
   PORT (
      cfd_discr_i       : IN     std_logic_vector (NUM_INPUTS-1 DOWNTO 0);
      clk_4x_logic      : IN     std_logic ;                                 -- ! Rising edge active
      logic_strobe_i    : IN     std_logic ;                                 -- ! Pulses high once every 4 cycles of clk_4x_logic
      threshold_discr_i : IN     std_logic_vector (NUM_INPUTS-1 DOWNTO 0);   -- ! inputs from threshold comparators
      trigger_times_o   : OUT    t_triggerTimeArray (NUM_INPUTS-1 DOWNTO 0); -- ! trigger arrival time ( w.r.t. logic_strobe)
      trigger_o         : OUT    std_logic_vector (NUM_INPUTS-1 DOWNTO 0);   -- ! High when trigger active
      ipbus_clk_i       : IN     std_logic ;
      ipbus_reset_i     : IN     std_logic ;
      ipbus_i           : IN     ipb_wbus ;                                  -- Signals from IPBus core TO slave
      ipbus_o           : OUT    ipb_rbus                                    -- signals from slave TO IPBus core
   );
   END COMPONENT triggerInputs;
   COMPONENT triggerLogic
   GENERIC (
      NUM_INPUTS : positive := 4
   );
   PORT (
      clk_4x_logic   : IN     std_logic ;                               -- ! Rising edge active
      ipbus_clk_i    : IN     std_logic ;
      ipbus_i        : IN     ipb_wbus ;                                -- Signals from IPBus core TO slave
      ipbus_reset_i  : IN     std_logic ;
      logic_strobe_i : IN     std_logic ;                               -- ! Pulses high once every 4 cycles of clk_4x_logic
      trigger_i      : IN     std_logic_vector (NUM_INPUTS-1 DOWNTO 0); -- ! High when trigger from input conector active
      veto_i         : IN     std_logic ;                               -- ! Halts triggers when high
      ipbus_o        : OUT    ipb_rbus ;                                -- signals from slave TO IPBus core
      trigger_o      : OUT    std_logic                                 -- ! goes high when trigger passes
   );
   END COMPONENT triggerLogic;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : DUTInterfaces USE ENTITY fmc_mTLU_lib.DUTInterfaces;
   FOR ALL : IPBusInterface USE ENTITY fmc_mTLU_lib.IPBusInterface;
   FOR ALL : eventBuffer USE ENTITY fmc_mTLU_lib.eventBuffer;
   FOR ALL : eventFormatter USE ENTITY fmc_mTLU_lib.eventFormatter;
   FOR ALL : logic_clocks USE ENTITY fmc_mTLU_lib.logic_clocks;
   FOR ALL : triggerInputs USE ENTITY fmc_mTLU_lib.triggerInputs;
   FOR ALL : triggerLogic USE ENTITY fmc_mTLU_lib.triggerLogic;
   -- pragma synthesis_on


BEGIN

   -- ModuleWare code(v1.9) for instance 'I8' of 'sor'
   overall_veto <= buffer_full_o OR veto_o;

   -- Instance port mappings.
   I0 : DUTInterfaces
      GENERIC MAP (
         NUM_DUTS    => NUM_DUTS,
         IPBUS_WIDTH => IPBUS_WIDTH
      )
      PORT MAP (
         busy_from_dut_i       => busy_i,
         clk_4x_logic_i        => clk_4x_logic,
         clk_from_dut_i        => dut_clk,
         ipbus_clk_i           => ipbus_clk,
         ipbus_i               => ipbw(0),
         ipbus_reset_i         => ipbus_reset,
         logic_strobe_i        => strobe_4x_logic,
         trigger_counter_i     => trigger_count,
         trigger_i             => overall_trigger,
         ipbus_o               => ipbr(0),
         reset_or_clk_to_dut_o => reset_or_clk_o,
         trigger_to_dut_o      => triggers_o,
         veto_o                => veto_o
      );
   I4 : IPBusInterface
      GENERIC MAP (
         NUM_EXT_SLAVES => NUM_EXT_SLAVES
      )
      PORT MAP (
         gmii_rx_clk_i    => gmii_rx_clk_i,
         gmii_rx_dv_i     => gmii_rx_dv_i,
         gmii_rx_er_i     => gmii_rx_er_i,
         gmii_rxd_i       => gmii_rxd_i,
         ipbr_i           => ipbr,
         sysclk_n_i       => sysclk_p_i,
         sysclk_p_i       => sysclk_n_i,
         clocks_locked_o  => OPEN,
         gmii_gtx_clk_o   => gmii_gtx_clk_o,
         gmii_tx_en_o     => gmii_tx_en_o,
         gmii_tx_er_o     => gmii_tx_er_o,
         gmii_txd_o       => gmii_txd_o,
         ipb_clk_o        => ipb_clk,
         ipb_rst_o        => ipb_rst,
         ipbw_o           => ipbw,
         onehz_o          => OPEN,
         phy_rstb_o       => phy_rstb_o,
         dip_switch_i     => dip_switch,
         clk_logic_xtal_o => clk_logic_xtal
      );
   I5 : eventBuffer
      GENERIC MAP (
         EVENT_DATA_WIDTH => 64,
         IPBUS_WIDTH      => 32
      )
      PORT MAP (
         clk_4x_logic_i    => clk_4x_logic,
         data_strobe_i     => data_strobe,
         event_data_i      => event_data,
         ipbus_clk_i       => ipbus_clk,
         ipbus_i           => ipbw(3),
         ipbus_reset_i     => ipbus_reset,
         strobe_4x_logic_i => strobe_4x_logic,
         trigger_count_i   => trigger_count,
         buffer_full_o     => buffer_full_o,
         ipbus_o           => ipbr(3)
      );
   I2 : eventFormatter
      GENERIC MAP (
         EVENT_DATA_WIDTH => 64,
         IPBUS_WIDTH      => 32,
         NUM_TRIG_INPUTS  => 4
      )
      PORT MAP (
         clk_4x_logic_i  => clk_4x_logic,
         logic_strobe_i  => strobe_4x_logic,
         trigger_i       => overall_trigger,
         trigger_times_i => trigger_times,
         data_strobe_o   => data_strobe,
         event_data_o    => event_data,
         trigger_count_o => trigger_count
      );
   I6 : logic_clocks
      PORT MAP (
         ipbus_clk_i        => ipbus_clk,
         ipbus_i            => ipbw(4),
         ipbus_reset_i      => ipbus_reset,
         clk_logic_xtal_i   => clk_logic_xtal,
         clk_16x_logic_O    => clk_16x_logic,
         clk_4x_logic_o     => clk_4x_logic,
         ipbus_o            => ipbr(4),
         strobe_16x_logic_O => strobe_16x_logic,
         strobe_4x_logic_O  => strobe_4x_logic,
         extclk_p_b         => extclk_p_b,
         extclk_n_b         => extclk_n_b,
         clk_logic_o        => OPEN
      );
   I1 : triggerInputs
      GENERIC MAP (
         NUM_INPUTS => 4
      )
      PORT MAP (
         cfd_discr_i       => cfd_discr_i,
         clk_4x_logic      => clk_4x_logic,
         logic_strobe_i    => strobe_4x_logic,
         threshold_discr_i => threshold_discr_i,
         trigger_times_o   => trigger_times,
         trigger_o         => triggers,
         ipbus_clk_i       => ipbus_clk,
         ipbus_reset_i     => ipbus_reset,
         ipbus_i           => ipbw(1),
         ipbus_o           => ipbr(1)
      );
   I3 : triggerLogic
      GENERIC MAP (
         NUM_INPUTS => 4
      )
      PORT MAP (
         clk_4x_logic   => clk_4x_logic,
         ipbus_clk_i    => ipbus_clk,
         ipbus_i        => ipbw(2),
         ipbus_reset_i  => ipbus_reset,
         logic_strobe_i => strobe_4x_logic,
         trigger_i      => triggers,
         veto_i         => overall_veto,
         ipbus_o        => ipbr(2),
         trigger_o      => overall_trigger
      );

END ARCHITECTURE struct;

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title></title>
<link rel="Stylesheet" title="hdl2html stylesheet" media="Screen" href="../../scripts/hdl2html.css">
<!-- Generated by HDL Designer -->
<!--    at 16:58:13 on 11/13/12 -->
<script language='javascript'>
function pagesBtn() {
   return '';
}
function panelmenu() {
   return '';
}
</script>
</head>
<body>
<pre>
<span class=C>-- VHDL Entity fmc_mTLU_lib.top_extphy.symbol</span>
<span class=C>--</span>
<span class=C>-- Created:</span>
<span class=C>--          by - phdgc.HEP_Instrumentation (kipper.phy.bris.ac.uk)</span>
<span class=C>--          at - 15:41:40 11&#47;13&#47;12</span>
<span class=C>--</span>
<span class=C>-- Generated by Mentor Graphics' HDL Designer(TM) 2010.3 (Build 21)</span>
<span class=C>--</span>
<span class=K>LIBRARY</span> ieee;
<span class=K>USE</span> ieee.std_logic_1164.<span class=K>all</span>;
<span class=K>USE</span> ieee.numeric_std.<span class=K>all</span>;

<span class=K>ENTITY</span> top_extphy <span class=K>IS</span>
   <span class=K>GENERIC</span>(
      NUM_DUTS         : positive := 3;
      NUM_TRIG_INPUTS  : positive := 4;
      NUM_SLAVES       : positive := 5;
      EVENT_DATA_WIDTH : positive := 64;
      IPBUS_WIDTH      : positive := 32
   );
   <span class=K>PORT</span>(
      busy_i            : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);
      cfd_discr_i       : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_TRIG_INPUTS-1 <span class=K>DOWNTO</span> 0);
      dip_switch        : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (3 <span class=K>DOWNTO</span> 0);
      dut_clk           : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);
      gmii_rx_clk_i     : <span class=A>IN</span>     <span class=T>std_logic</span>;
      gmii_rx_dv_i      : <span class=A>IN</span>     <span class=T>std_logic</span>;
      gmii_rx_er_i      : <span class=A>IN</span>     <span class=T>std_logic</span>;
      gmii_rxd_i        : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (7 <span class=K>DOWNTO</span> 0);
      sysclk_n_i        : <span class=A>IN</span>     <span class=T>std_logic</span>;
      sysclk_p_i        : <span class=A>IN</span>     <span class=T>std_logic</span>;                                      <span class=C>-- ! 200 MHz xtal clock</span>
      threshold_discr_i : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_TRIG_INPUTS-1 <span class=K>DOWNTO</span> 0);
      gmii_gtx_clk_o    : <span class=A>OUT</span>    <span class=T>std_logic</span>;
      gmii_tx_en_o      : <span class=A>OUT</span>    <span class=T>std_logic</span>;
      gmii_tx_er_o      : <span class=A>OUT</span>    <span class=T>std_logic</span>;
      gmii_txd_o        : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (7 <span class=K>DOWNTO</span> 0);
      i2c_scl_o         : <span class=A>OUT</span>    <span class=T>std_logic</span>;
      leds              : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (3 <span class=K>DOWNTO</span> 0);
      leds_o            : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (3 <span class=K>DOWNTO</span> 0);
      phy_rstb_o        : <span class=A>OUT</span>    <span class=T>std_logic</span>;
      reset_or_clk_o    : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);
      triggers_o        : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);
      i2c_sda_d         : <span class=A>INOUT</span>  <span class=T>std_logic</span>
   );

<span class=C>-- Declarations</span>

<span class=K>END</span> <span class=K>ENTITY</span> top_extphy ;

<span class=C>--</span>
<span class=C>-- VHDL Architecture fmc_mTLU_lib.top_extphy.struct</span>
<span class=C>--</span>
<span class=C>-- Created:</span>
<span class=C>--          by - phdgc.HEP_Instrumentation (kipper.phy.bris.ac.uk)</span>
<span class=C>--          at - 15:41:41 11&#47;13&#47;12</span>
<span class=C>--</span>
<span class=C>-- Generated by Mentor Graphics' HDL Designer(TM) 2010.3 (Build 21)</span>
<span class=C>--</span>
<span class=K>LIBRARY</span> ieee;
<span class=K>USE</span> ieee.std_logic_1164.<span class=K>all</span>;
<span class=K>USE</span> ieee.numeric_std.<span class=K>all</span>;

<span class=K>LIBRARY</span> work;
<span class=K>USE</span> work.ipbus.<span class=K>all</span>;
<span class=K>USE</span> work.emac_hostbus_decl.<span class=K>all</span>;

<span class=K>USE</span> work.fmcTLU.<span class=K>all</span>;

<span class=K>LIBRARY</span> fmc_mTLU_lib;

<span class=K>ARCHITECTURE</span> struct <span class=K>OF</span> top_extphy <span class=K>IS</span>

   <span class=C>-- Architecture declarations</span>

   <span class=C>-- Internal signal declarations</span>
   <span class=K>SIGNAL</span> clk_4x_logic    : <span class=T>std_logic</span>;                                         <span class=C>-- ! normally 160MHz</span>
   <span class=K>SIGNAL</span> data_strobe     : <span class=T>std_logic</span>;                                         <span class=C>-- goes high when data ready to load into event buffer</span>
   <span class=K>SIGNAL</span> dut_veto        : <span class=T>std_logic</span>;                                         <span class=C>-- goes high when one or more DUT are busy</span>
   <span class=K>SIGNAL</span> event_data      : <span class=T>std_logic_vector</span>(EVENT_DATA_WIDTH-1 <span class=K>DOWNTO</span> 0);
   <span class=K>SIGNAL</span> ipb_clk         : <span class=T>std_logic</span>;                                         <span class=C>-- ! IPBus clock to slaves</span>
   <span class=K>SIGNAL</span> ipb_rst         : <span class=T>std_logic</span>;                                         <span class=C>-- ! IPBus reset to slaves</span>
   <span class=K>SIGNAL</span> ipbr            : ipb_rbus_array(NUM_SLAVES-2 <span class=K>DOWNTO</span> 0);             <span class=C>-- ! IPBus read signals</span>
   <span class=K>SIGNAL</span> ipbus_clk       : <span class=T>std_logic</span>;
   <span class=K>SIGNAL</span> ipbus_reset     : <span class=T>std_logic</span>;
   <span class=K>SIGNAL</span> ipbw            : ipb_wbus_array(NUM_SLAVES-2 <span class=K>DOWNTO</span> 0);             <span class=C>-- ! IBus write signals</span>
   <span class=K>SIGNAL</span> logic_strobe    : <span class=T>std_logic</span>;                                         <span class=C>-- ! Pulses high once every 4 cycles of clk_4x_logic</span>
   <span class=K>SIGNAL</span> overall_trigger : <span class=T>std_logic</span>;                                         <span class=C>-- goes high to load trigger data</span>
   <span class=K>SIGNAL</span> overall_veto    : <span class=T>std_logic</span>;                                         <span class=C>-- ! Halts triggers when high</span>
   <span class=K>SIGNAL</span> trigger_count   : <span class=T>std_logic_vector</span>(IPBUS_WIDTH-1 <span class=K>DOWNTO</span> 0);
   <span class=K>SIGNAL</span> trigger_times   : t_triggerTimeArray(NUM_TRIG_INPUTS-1 <span class=K>DOWNTO</span> 0);    <span class=C>-- ! trigger arrival time ( w.r.t. logic_strobe)</span>
   <span class=K>SIGNAL</span> triggers        : <span class=T>std_logic_vector</span>(NUM_TRIG_INPUTS-1 <span class=K>DOWNTO</span> 0);      <span class=C>-- ! High when trigger from input conector active</span>


   <span class=C>-- Component Declarations</span>
   <span class=K>COMPONENT</span> DUTInterfaces
   <span class=K>GENERIC</span> (
      NUM_DUTS    : positive := 3;
      IPBUS_WIDTH : positive := 32
   );
   <span class=K>PORT</span> (
      busy_from_dut_i       : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);  <span class=C>-- BUSY input from DUTs</span>
      clk_4x_logic_i        : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      clk_from_dut_i        : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);  <span class=C>-- clocks trigger data when in EUDET mode</span>
      ipbus_clk_i           : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      ipbus_i               : <span class=A>IN</span>     ipb_wbus ;                               <span class=C>-- Signals from IPBus core TO slave</span>
      ipbus_reset_i         : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      logic_strobe_i        : <span class=A>IN</span>     <span class=T>std_logic</span> ;                              <span class=C>-- ! goes high every 4th clock cycle</span>
      trigger_counter_i     : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (IPBUS_WIDTH-1 <span class=K>DOWNTO</span> 0);
      trigger_i             : <span class=A>IN</span>     <span class=T>std_logic</span> ;                              <span class=C>-- goes high when trigger logic issues a trigger</span>
      ipbus_o               : <span class=A>OUT</span>    ipb_rbus ;                               <span class=C>-- signals from slave TO IPBus core</span>
      reset_or_clk_to_dut_o : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);  <span class=C>-- ! Either reset line or trigger</span>
      trigger_to_dut_o      : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (NUM_DUTS-1 <span class=K>DOWNTO</span> 0);  <span class=C>-- ! Trigger output</span>
      veto_o                : <span class=A>OUT</span>    <span class=T>std_logic</span>                                <span class=C>-- goes high when one or more DUT are busy</span>
   );
   <span class=K>END</span> <span class=K>COMPONENT</span> DUTInterfaces;
   <span class=K>COMPONENT</span> IPBusInterface
   <span class=K>GENERIC</span> (
      NUM_SLAVES : positive := 6
   );
   <span class=K>PORT</span> (
      gmii_rx_clk_i   : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      gmii_rx_dv_i    : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      gmii_rx_er_i    : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      gmii_rxd_i      : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (7 <span class=K>DOWNTO</span> 0);
      ipbr_i          : <span class=A>IN</span>     ipb_rbus_array (NUM_SLAVES-2 <span class=K>DOWNTO</span> 0); <span class=C>-- ! IPBus read signals</span>
      sysclk_n_i      : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      sysclk_p_i      : <span class=A>IN</span>     <span class=T>std_logic</span> ;                             <span class=C>-- ! 200 MHz xtal clock</span>
      clk_4x_logic_o  : <span class=A>OUT</span>    <span class=T>std_logic</span> ;                             <span class=C>-- ! normally 160MHz</span>
      clocks_locked_o : <span class=A>OUT</span>    <span class=T>std_logic</span> ;
      gmii_gtx_clk_o  : <span class=A>OUT</span>    <span class=T>std_logic</span> ;
      gmii_tx_en_o    : <span class=A>OUT</span>    <span class=T>std_logic</span> ;
      gmii_tx_er_o    : <span class=A>OUT</span>    <span class=T>std_logic</span> ;
      gmii_txd_o      : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (7 <span class=K>DOWNTO</span> 0);
      ipb_clk_o       : <span class=A>OUT</span>    <span class=T>std_logic</span> ;                             <span class=C>-- ! IPBus clock TO slaves</span>
      ipb_rst_o       : <span class=A>OUT</span>    <span class=T>std_logic</span> ;                             <span class=C>-- ! IPBus reset TO slaves</span>
      ipbw_o          : <span class=A>OUT</span>    ipb_wbus_array (NUM_SLAVES-2 <span class=K>DOWNTO</span> 0); <span class=C>-- ! IBus write signals</span>
      logic_strobe_o  : <span class=A>OUT</span>    <span class=T>std_logic</span> ;                             <span class=C>-- ! 40MHz strobe sync with 160MHz clock</span>
      onehz_o         : <span class=A>OUT</span>    <span class=T>std_logic</span> ;
      phy_rstb_o      : <span class=A>OUT</span>    <span class=T>std_logic</span> ;
      dip_switch_i    : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (3 <span class=K>DOWNTO</span> 0)
   );
   <span class=K>END</span> <span class=K>COMPONENT</span> IPBusInterface;
   <span class=K>COMPONENT</span> eventBuffer
   <span class=K>PORT</span> (
      clk_4x_logic_i  : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      data_strobe_i   : <span class=A>IN</span>     <span class=T>std_logic</span> ;                                   <span class=C>-- Indicates data TO transfer</span>
      event_data_i    : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (EVENT_DATA_WIDTH-1 <span class=K>DOWNTO</span> 0);
      ipbus_clk_i     : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      ipbus_i         : <span class=A>IN</span>     ipb_wbus ;
      ipbus_reset_i   : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      logic_strobe_i  : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      trigger_count_i : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (IPBUS_WIDTH-1 <span class=K>DOWNTO</span> 0);
      ipbus_o         : <span class=A>OUT</span>    ipb_rbus
   );
   <span class=K>END</span> <span class=K>COMPONENT</span> eventBuffer;
   <span class=K>COMPONENT</span> eventFormatter
   <span class=K>GENERIC</span> (
      EVENT_DATA_WIDTH : positive := 64;
      IPBUS_WIDTH      : positive := 32;
      NUM_TRIG_INPUTS  : positive := 4
   );
   <span class=K>PORT</span> (
      clk_4x_logic_i  : <span class=A>IN</span>     <span class=T>std_logic</span> ;                                      <span class=C>-- ! Rising edge active</span>
      logic_strobe_i  : <span class=A>IN</span>     <span class=T>std_logic</span> ;                                      <span class=C>-- ! Pulses high once every 4 cycles of clk_4x_logic</span>
      trigger_i       : <span class=A>IN</span>     <span class=T>std_logic</span> ;                                      <span class=C>-- goes high TO load trigger data</span>
      trigger_times_i : <span class=A>IN</span>     t_triggerTimeArray (NUM_TRIG_INPUTS-1 <span class=K>DOWNTO</span> 0); <span class=C>-- Array of trigger times ( w.r.t. logic_strobe)</span>
      data_strobe_o   : <span class=A>OUT</span>    <span class=T>std_logic</span> ;                                      <span class=C>-- goes high when data ready TO load into event buffer</span>
      event_data_o    : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (EVENT_DATA_WIDTH-1 <span class=K>DOWNTO</span> 0);
      trigger_count_o : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (IPBUS_WIDTH-1 <span class=K>DOWNTO</span> 0)
   );
   <span class=K>END</span> <span class=K>COMPONENT</span> eventFormatter;
   <span class=K>COMPONENT</span> triggerInputs
   <span class=K>GENERIC</span> (
      NUM_INPUTS : <span class=T>natural</span> := 4
   );
   <span class=K>PORT</span> (
      cfd_discr_i       : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_INPUTS-1 <span class=K>DOWNTO</span> 0);
      clk_4x_logic      : <span class=A>IN</span>     <span class=T>std_logic</span> ;                                 <span class=C>-- ! Rising edge active</span>
      logic_strobe_i    : <span class=A>IN</span>     <span class=T>std_logic</span> ;                                 <span class=C>-- ! Pulses high once every 4 cycles of clk_4x_logic</span>
      threshold_discr_i : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_INPUTS-1 <span class=K>DOWNTO</span> 0);   <span class=C>-- ! inputs from threshold comparators</span>
      trigger_times_o   : <span class=A>OUT</span>    t_triggerTimeArray (NUM_INPUTS-1 <span class=K>DOWNTO</span> 0); <span class=C>-- ! trigger arrival time ( w.r.t. logic_strobe)</span>
      trigger_o         : <span class=A>OUT</span>    <span class=T>std_logic_vector</span> (NUM_INPUTS-1 <span class=K>DOWNTO</span> 0);   <span class=C>-- ! High when trigger active</span>
      ipbus_clk_i       : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      ipbus_reset_i     : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      ipbus_i           : <span class=A>IN</span>     ipb_wbus ;                                  <span class=C>-- Signals from IPBus core TO slave</span>
      ipbus_o           : <span class=A>OUT</span>    ipb_rbus                                    <span class=C>-- signals from slave TO IPBus core</span>
   );
   <span class=K>END</span> <span class=K>COMPONENT</span> triggerInputs;
   <span class=K>COMPONENT</span> triggerLogic
   <span class=K>GENERIC</span> (
      NUM_INPUTS : positive := 4
   );
   <span class=K>PORT</span> (
      clk_4x_logic   : <span class=A>IN</span>     <span class=T>std_logic</span> ;                               <span class=C>-- ! Rising edge active</span>
      ipbus_clk_i    : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      ipbus_i        : <span class=A>IN</span>     ipb_wbus ;                                <span class=C>-- Signals from IPBus core TO slave</span>
      ipbus_reset_i  : <span class=A>IN</span>     <span class=T>std_logic</span> ;
      logic_strobe_i : <span class=A>IN</span>     <span class=T>std_logic</span> ;                               <span class=C>-- ! Pulses high once every 4 cycles of clk_4x_logic</span>
      trigger_i      : <span class=A>IN</span>     <span class=T>std_logic_vector</span> (NUM_INPUTS-1 <span class=K>DOWNTO</span> 0); <span class=C>-- ! High when trigger from input conector active</span>
      veto_i         : <span class=A>IN</span>     <span class=T>std_logic</span> ;                               <span class=C>-- ! Halts triggers when high</span>
      ipbus_o        : <span class=A>OUT</span>    ipb_rbus ;                                <span class=C>-- signals from slave TO IPBus core</span>
      trigger_o      : <span class=A>OUT</span>    <span class=T>std_logic</span>                                 <span class=C>-- ! goes high when trigger passes</span>
   );
   <span class=K>END</span> <span class=K>COMPONENT</span> triggerLogic;

   <span class=C>-- Optional embedded configurations</span>
   <span class=C>-- pragma synthesis_off</span>
   <span class=K>FOR</span> <span class=K>ALL</span> : DUTInterfaces <span class=K>USE</span> <span class=K>ENTITY</span> fmc_mTLU_lib.DUTInterfaces;
   <span class=K>FOR</span> <span class=K>ALL</span> : IPBusInterface <span class=K>USE</span> <span class=K>ENTITY</span> fmc_mTLU_lib.IPBusInterface;
   <span class=K>FOR</span> <span class=K>ALL</span> : eventBuffer <span class=K>USE</span> <span class=K>ENTITY</span> fmc_mTLU_lib.eventBuffer;
   <span class=K>FOR</span> <span class=K>ALL</span> : eventFormatter <span class=K>USE</span> <span class=K>ENTITY</span> fmc_mTLU_lib.eventFormatter;
   <span class=K>FOR</span> <span class=K>ALL</span> : triggerInputs <span class=K>USE</span> <span class=K>ENTITY</span> fmc_mTLU_lib.triggerInputs;
   <span class=K>FOR</span> <span class=K>ALL</span> : triggerLogic <span class=K>USE</span> <span class=K>ENTITY</span> fmc_mTLU_lib.triggerLogic;
   <span class=C>-- pragma synthesis_on</span>


<span class=K>BEGIN</span>

   <span class=C>-- Instance port mappings.</span>
   I0 : DUTInterfaces
      <span class=K>GENERIC</span> <span class=K>MAP</span> (
         NUM_DUTS    => 3,
         IPBUS_WIDTH => 32
      )
      <span class=K>PORT</span> <span class=K>MAP</span> (
         busy_from_dut_i       => busy_i,
         clk_4x_logic_i        => clk_4x_logic,
         clk_from_dut_i        => dut_clk,
         ipbus_clk_i           => ipbus_clk,
         ipbus_i               => ipbw(0),
         ipbus_reset_i         => ipbus_reset,
         logic_strobe_i        => logic_strobe,
         trigger_counter_i     => trigger_count,
         trigger_i             => overall_trigger,
         ipbus_o               => ipbr(0),
         reset_or_clk_to_dut_o => <span class=K>OPEN</span>,
         trigger_to_dut_o      => <span class=K>OPEN</span>,
         veto_o                => dut_veto
      );
   I4 : IPBusInterface
      <span class=K>GENERIC</span> <span class=K>MAP</span> (
         NUM_SLAVES => NUM_SLAVES
      )
      <span class=K>PORT</span> <span class=K>MAP</span> (
         gmii_rx_clk_i   => gmii_rx_clk_i,
         gmii_rx_dv_i    => gmii_rx_dv_i,
         gmii_rx_er_i    => gmii_rx_er_i,
         gmii_rxd_i      => gmii_rxd_i,
         ipbr_i          => ipbr,
         sysclk_n_i      => sysclk_p_i,
         sysclk_p_i      => sysclk_n_i,
         clk_4x_logic_o  => clk_4x_logic,
         clocks_locked_o => <span class=K>OPEN</span>,
         gmii_gtx_clk_o  => gmii_gtx_clk_o,
         gmii_tx_en_o    => gmii_tx_en_o,
         gmii_tx_er_o    => gmii_tx_er_o,
         gmii_txd_o      => gmii_txd_o,
         ipb_clk_o       => ipb_clk,
         ipb_rst_o       => ipb_rst,
         ipbw_o          => ipbw,
         logic_strobe_o  => logic_strobe,
         onehz_o         => <span class=K>OPEN</span>,
         phy_rstb_o      => phy_rstb_o,
         dip_switch_i    => dip_switch
      );
   I5 : eventBuffer
      <span class=K>PORT</span> <span class=K>MAP</span> (
         clk_4x_logic_i  => clk_4x_logic,
         data_strobe_i   => data_strobe,
         event_data_i    => event_data,
         ipbus_clk_i     => ipbus_clk,
         ipbus_i         => ipbw(3),
         ipbus_reset_i   => ipbus_reset,
         logic_strobe_i  => logic_strobe,
         trigger_count_i => trigger_count,
         ipbus_o         => ipbr(3)
      );
   I2 : eventFormatter
      <span class=K>GENERIC</span> <span class=K>MAP</span> (
         EVENT_DATA_WIDTH => 64,
         IPBUS_WIDTH      => 32,
         NUM_TRIG_INPUTS  => 4
      )
      <span class=K>PORT</span> <span class=K>MAP</span> (
         clk_4x_logic_i  => clk_4x_logic,
         logic_strobe_i  => logic_strobe,
         trigger_i       => overall_trigger,
         trigger_times_i => trigger_times,
         data_strobe_o   => data_strobe,
         event_data_o    => event_data,
         trigger_count_o => trigger_count
      );
   I1 : triggerInputs
      <span class=K>GENERIC</span> <span class=K>MAP</span> (
         NUM_INPUTS => 4
      )
      <span class=K>PORT</span> <span class=K>MAP</span> (
         cfd_discr_i       => cfd_discr_i,
         clk_4x_logic      => clk_4x_logic,
         logic_strobe_i    => logic_strobe,
         threshold_discr_i => threshold_discr_i,
         trigger_times_o   => trigger_times,
         trigger_o         => triggers,
         ipbus_clk_i       => ipbus_clk,
         ipbus_reset_i     => ipbus_reset,
         ipbus_i           => ipbw(1),
         ipbus_o           => ipbr(1)
      );
   I3 : triggerLogic
      <span class=K>GENERIC</span> <span class=K>MAP</span> (
         NUM_INPUTS => 4
      )
      <span class=K>PORT</span> <span class=K>MAP</span> (
         clk_4x_logic   => clk_4x_logic,
         ipbus_clk_i    => ipbus_clk,
         ipbus_i        => ipbw(2),
         ipbus_reset_i  => ipbus_reset,
         logic_strobe_i => logic_strobe,
         trigger_i      => triggers,
         veto_i         => overall_veto,
         ipbus_o        => ipbr(2),
         trigger_o      => overall_trigger
      );

<span class=K>END</span> <span class=K>ARCHITECTURE</span> struct;</pre>
<SCRIPT SRC="../../scripts/is.js"></SCRIPT><SCRIPT SRC="../../scripts/imageFrame.js"></SCRIPT>
</body>
